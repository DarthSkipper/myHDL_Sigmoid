-- File: ../out/vhdl/sigmoid.vhd
-- Generated by MyHDL 0.10
-- Date: Wed Dec 12 18:41:49 2018


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_010.all;

entity sigmoid is
    port (
        t_clk: in std_logic;
        t_reset: in std_logic;
        t_y_out_tdata: out unsigned(31 downto 0);
        t_y_out_tready: in std_logic;
        t_y_out_tvalid: in std_logic;
        t_y_out_tlast: in std_logic;
        exponential0_t_x: in unsigned(31 downto 0);
        t_x_tready: in std_logic;
        t_x_tvalid: in std_logic;
        t_x_tlast: in std_logic
    );
end entity sigmoid;
-- :param x:
-- :param prec:
-- :return:

architecture MyHDL of sigmoid is


type t_enum_state_t_1 is (
    count,
    result
);
type t_enum_state_t_2 is (
    count,
    result
);
type t_enum_state_t_3 is (
    count,
    result
);
type t_enum_state_t_4 is (
    count,
    result
);
signal t_exp_start: unsigned(31 downto 0);
signal t_exp_out: unsigned(31 downto 0);
signal t_exp_end: unsigned(31 downto 0);
signal state: t_enum_state_t_4;
signal const_1: unsigned(31 downto 0);
signal accumulator: unsigned(31 downto 0);
signal exponential0_y_pow: unsigned(31 downto 0);
signal exponential0_y_fac: unsigned(31 downto 0);
signal exponential0_t_pow_start: unsigned(31 downto 0);
signal exponential0_t_pow_end: unsigned(31 downto 0);
signal exponential0_t_fac_start: unsigned(31 downto 0);
signal exponential0_t_fac_end: unsigned(31 downto 0);
signal exponential0_state: t_enum_state_t_3;
signal exponential0_counter: unsigned(31 downto 0);
signal exponential0_const_1: unsigned(31 downto 0);
signal exponential0_accumulator: unsigned(31 downto 0);
signal exponential0_power0_state: t_enum_state_t_1;
signal exponential0_power0_counter: unsigned(31 downto 0);
signal exponential0_power0_accumulator: unsigned(31 downto 0);
signal exponential0_factorial0_state: t_enum_state_t_2;
signal exponential0_factorial0_counter: unsigned(31 downto 0);
signal exponential0_factorial0_accumulator: unsigned(31 downto 0);

begin


const_1 <= unsigned'("00000000000000010000000000000000");
exponential0_const_1 <= unsigned'("00000000000000010000000000000000");


-- :return:
SIGMOID_EXPONENTIAL0_POWER0_POWERS: process (t_clk) is
begin
    if rising_edge(t_clk) then
        if (t_reset = '1') then
            exponential0_power0_counter <= to_unsigned(0, 32);
            exponential0_power0_state <= count;
            exponential0_power0_accumulator <= to_unsigned(1, 32);
            exponential0_y_pow <= to_unsigned(0, 32);
            exponential0_t_pow_end <= to_unsigned(0, 32);
        else
            case exponential0_power0_state is
                when count =>
                    if (exponential0_t_pow_start = 1) then
                        exponential0_t_pow_end <= to_unsigned(0, 32);
                        exponential0_power0_accumulator <= resize(exponential0_power0_accumulator * exponential0_t_x, 32);
                        exponential0_power0_counter <= (exponential0_power0_counter + 1);
                        if (signed(resize(exponential0_power0_counter, 33)) >= (signed(resize(exponential0_counter, 33)) - 1)) then
                            exponential0_power0_state <= result;
                            exponential0_power0_counter <= to_unsigned(0, 32);
                        end if;
                    end if;
                when result =>
                    exponential0_t_pow_end <= to_unsigned(1, 32);
                    exponential0_y_pow <= exponential0_power0_accumulator;
                    exponential0_power0_accumulator <= to_unsigned(1, 32);
                    exponential0_power0_state <= count;
                when others =>
                    assert False report "End of Simulation" severity Failure;
            end case;
        end if;
    end if;
end process SIGMOID_EXPONENTIAL0_POWER0_POWERS;

SIGMOID_EXPONENTIAL0_FACTORIAL0_FACTORIALS: process (t_clk) is
begin
    if rising_edge(t_clk) then
        if (t_reset = '1') then
            exponential0_factorial0_counter <= to_unsigned(0, 32);
            exponential0_factorial0_state <= count;
            exponential0_factorial0_accumulator <= to_unsigned(1, 32);
            exponential0_y_fac <= to_unsigned(1, 32);
            exponential0_t_fac_end <= to_unsigned(0, 32);
        else
            case exponential0_factorial0_state is
                when count =>
                    if (exponential0_t_fac_start = 1) then
                        exponential0_t_fac_end <= to_unsigned(0, 32);
                        if (exponential0_factorial0_counter = 0) then
                            exponential0_factorial0_counter <= to_unsigned(1, 32);
                            exponential0_factorial0_accumulator <= to_unsigned(1, 32);
                        else
                            exponential0_factorial0_accumulator <= resize(exponential0_factorial0_accumulator * exponential0_factorial0_counter, 32);
                            exponential0_factorial0_counter <= (exponential0_factorial0_counter + 1);
                        end if;
                        if (signed(resize(exponential0_factorial0_counter, 33)) > (signed(resize(exponential0_counter, 33)) - 1)) then
                            exponential0_factorial0_state <= result;
                            exponential0_factorial0_counter <= to_unsigned(0, 32);
                        end if;
                    end if;
                when result =>
                    exponential0_t_fac_end <= to_unsigned(1, 32);
                    exponential0_y_fac <= exponential0_factorial0_accumulator;
                    exponential0_factorial0_accumulator <= to_unsigned(1, 32);
                    exponential0_factorial0_state <= count;
                when others =>
                    assert False report "End of Simulation" severity Failure;
            end case;
        end if;
    end if;
end process SIGMOID_EXPONENTIAL0_FACTORIAL0_FACTORIALS;

-- :return:
SIGMOID_EXPONENTIAL0_EXPONENTIALS: process (t_clk) is
begin
    if rising_edge(t_clk) then
        if (t_reset = '1') then
            t_exp_end <= to_unsigned(0, 32);
            exponential0_counter <= to_unsigned(0, 32);
            exponential0_state <= count;
            exponential0_t_fac_start <= to_unsigned(1, 32);
            exponential0_accumulator <= to_unsigned(0, 32);
            t_exp_out <= to_unsigned(0, 32);
            exponential0_t_pow_start <= to_unsigned(1, 32);
        else
            case exponential0_state is
                when count =>
                    if (t_exp_start = 1) then
                        t_exp_end <= to_unsigned(0, 32);
                        if ((exponential0_t_pow_end = 1) and (exponential0_t_fac_end = 1)) then
                            exponential0_t_pow_start <= to_unsigned(0, 32);
                            exponential0_t_fac_start <= to_unsigned(0, 32);
                            if (exponential0_counter = 0) then
                                exponential0_counter <= to_unsigned(1, 32);
                                exponential0_accumulator <= exponential0_const_1;
                            else
                                exponential0_accumulator <= (exponential0_accumulator + (shift_left(shift_left(exponential0_y_pow, 16), 16) / shift_left(exponential0_y_fac, 16)));
                                exponential0_counter <= (exponential0_counter + 1);
                            end if;
                            if (signed(resize(exponential0_counter, 33)) > (4 - 1)) then
                                exponential0_state <= result;
                                exponential0_counter <= to_unsigned(0, 32);
                            end if;
                            exponential0_t_pow_start <= to_unsigned(1, 32);
                            exponential0_t_fac_start <= to_unsigned(1, 32);
                        end if;
                    end if;
                when result =>
                    exponential0_t_pow_start <= to_unsigned(1, 32);
                    exponential0_t_fac_start <= to_unsigned(1, 32);
                    t_exp_end <= to_unsigned(1, 32);
                    t_exp_out <= exponential0_accumulator;
                    exponential0_accumulator <= exponential0_const_1;
                    exponential0_state <= count;
                when others =>
                    assert False report "End of Simulation" severity Failure;
            end case;
        end if;
    end if;
end process SIGMOID_EXPONENTIAL0_EXPONENTIALS;

-- :return:
SIGMOID_SIGMOIDS: process (t_clk) is
begin
    if rising_edge(t_clk) then
        if (t_reset = '1') then
            t_y_out_tdata <= to_unsigned(0, 32);
            state <= count;
            accumulator <= to_unsigned(0, 32);
            t_exp_start <= to_unsigned(1, 32);
        else
            case state is
                when count =>
                    if (t_exp_end = 1) then
                        t_exp_start <= to_unsigned(0, 32);
                        accumulator <= (shift_left(t_exp_out, 16) / (t_exp_out + const_1));
                        state <= result;
                    end if;
                when result =>
                    t_exp_start <= to_unsigned(1, 32);
                    t_y_out_tdata <= accumulator;
                    state <= count;
                when others =>
                    assert False report "End of Simulation" severity Failure;
            end case;
        end if;
    end if;
end process SIGMOID_SIGMOIDS;

end architecture MyHDL;
